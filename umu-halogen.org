#+TITLE: umu-halogen

- Halogen scaffold generator
* Features
** DONE Generate Files/Directories
- [X] src directory
- [X] html directory
- [X] test directory
- [X] test/Main.purs
- [X] src/Main.purs
- [X] Component directory
- [X] Component/Title.purs
- [X] package.json file with the following deps
  - http-server
  - parcel-bundler
- [X] Makefile
** DONE Install to local nixpkgs
** DONE Generate Project
** DONE Error Handling
** DONE Logging
** DONE Generate Component
- with the command ~umu-halogen component <path> <component-name>~ generate a component.
** DONE Add information for component to be in a route
- add Slot, and SProxy
** TODO Use flags
- consider using flags for the input to prevent confusion and wrong inputs.
  Flags: ~location~ and ~name~, short flags ~l~ and ~n~
- Instead of using just ~Text -> Text -> ...~ as input. Use some ~newtype~
** DONE Generate Routing with initial generation
- [X] generating Router should also generate the Route
- [X] generate a place holder Route with Home as the initial route.
- [X] generate a Home page component?
- [X] generate Router component
- [X] generate AppM.purs, file with custom monad.
- [X] add two initial page
  - Home and About
- [X] add safeHref for navbar links
- [X] Home and About page should be added to the router
** TODO Add page to existing router.
- I'm not sure how to do this.
- Look into manipulating ASTs
- Look into pscid https://github.com/kRITZCREEK/pscid
- Look into pscide https://github.com/kritzcreek/purescript-psc-ide
** DONE Add Route on existing router
- Example command
#+begin_src
  umu-halogen route [PROJECT_LOCATION] [ROUTE]
#+end_src
- [X] add a data constructor to Route data type
- [ ] add a route codec that corresponds to the route input.
- [ ] add page component to the router component

* Issues
** DONE It doesn't generate directory if it doesn't exist.
** DONE Rename html folder to assets
** DONE include hot module reloading
** DONE Parcel Cannot resolve depedency
- I had a foreign function that was referencing an image in the assets
  directory. After compilation the foreign function file was located in the
  output/Assets/foreign.js. The actual images were located in assets/*.jpg/
  directory structure:
  #+begin_src
    |-- assets
    |-- output
        |-- Assets
            |-- foreign.js
  #+end_src
** DONE Makefile and asset not pointing to right files
- revereted Makefile to original state and this caused this bug
** TODO Create a code map
- This code map will guide someone who is unfamiliar to the code.
** DONE fix mkModuleName
- fix parsing in mkModuleName. ~ModuleName~'s constructor has updated from
  ~ModuleName [ PropareName Namespace ]~ to ~ModuleName Text~
** TODO Generated route in routeCodec, not kebab-case
* Other Tasks
** DONE Nix Build
- Set up nix files so project can be built with nix.
** TODO Update README with new feature
- ~add route~ features should be added to readme.
** TODO Remove purescript-ast & purescript-cst
- When the purescript team separates purescript-ast and purescript-cst remove
  these packages.
* Refactor
** DONE File Generation File Path Check
- There's a repeated pattern on path checking, this can be contained in one function.
** DONE Directory existence check
- there is a repeated line that checks for the existence of a directory, example:
  #+begin_src
  res <- liftIO
    $ tryJust ( guard . isAlreadyExistsError )
    $ TP.mkdir ( Turtle.fromText $ mkPathName mLoc "src/Component" )
  #+end_src
** DONE Directory generation: refactor dirname
- refactor and place ~dirName~ in where clause
** DONE Refactor file generation function
#+begin_src
  liftIO $ TP.writeTextFile ( Turtle.fromText $ mkPathName mPathInput filePath ) srcMainFile
  logInfo ( "Generated " <> filePath  )
#+end_src
** DONE if..then..else is scattered everywhere
- refactor this line
  #+begin_src
  if isExists
    then logError $ filePath <> " already exists!"
    else generateFile mPathInput filePath indexJS
  #+end_src
** DONE Directory Generation Response Handler
- the generation response handler is repeated in every directory generation function
** DONE Rename UmuHalogen.Capability.LogMessage
- rename ~UmuHalogen.Capability.LogMessage~ to ~UmuHalogen.Capability.Log~
** DONE Lock Nixpkgs
** DONE Spago.dhall project name
- It's currently hard coded to "my-halogen-project". It should also take in the
  name of the project. When the user inputs ~umu-halogen init example~
  spago.dhall should be:
  #+begin_src:
    { name = "example"
    , dependencies =
        [ "console", "effect", "halogen", "psci-support" ]
    , packages = ./packages.dhall
    , sources = [ "src/**/*.purs", "test/**/*.purs" ]
    }
  #+end_src:
- if there is not input with ~umu-halogen init~ get the parent directory.
** DONE validate generateComponent inputs
- input to ~generateComponent~ is ~Text -> Text -> m ()~ which is path and
  component name. Take first path parameter and encode it as a valid path, take
  component name input and encode it as proper component name, meaning it should
  be in pascal case even when the user inputs something like "title"
- I think I can embed the validation/sanitization of the inputs in the parser.
  The reason I didn't do this in the umu-react-basic because I thought I was
  just mindlessly wrapping the text input with the newtype constructor.
** DONE Rename ManageCommand to ManageGeneration
- this typeclass should focus on generation
** DONE Write file function is repeated
- not sure if this is a good idea, but I think I can have one writeFile function
  and take in a list of filenames to generate.
  - idea:
    #+begin_src:
      data SomeDataType = SomeDataType
        { pathInput :: Maybe Text
        , filePath :: Text
        , file :: Text
        }

      generateFiles mPathInput = traverse_ writeFileFn ( $ mPathInput ) [ srcMainFile ]

      writeFileFn :: MaybeText -> SomeDataType -> m ()

      srcMainFile :: Maybe Text -> SomeDataType
      srcMainFile pathIput = SomeDataType pathInput "src/Main.purs" srcMainFile
    #+end_src:
** DONE Write directory function is repeated
- Similar to the refactor of write file function.
** DONE Use parser combinators for path encoding
#+begin_src:
    discardFirstDot :: Text -> Maybe ( Char, Text )
    discardFirstDot = T.uncons

    filterLower :: [ Text ]  -> [ Text ]
    filterLower = filter ( not . all isLower )

    concatWithDot :: [ Text ] -> Text
    concatWithDot = concat . fmap ( "." <> )

    splitAtPathSeparator :: Text -> [ Text ]
    splitAtPathSeparator = T.split ( FP.pathSeparator == )
#+end_src
** DONE Bring up the error in the AppM
#+begin_src
    newtype AppM m a =
      AppM { unAppM :: ( ExceptT Error m ) a }
#+end_src
- Every function should have the ~MonaError GenerationError m~ signautre
** DONE use ReaderT and have Command as the input.
** DONE Switch to relude
** DONE isFileExists should return a sumtype
- a sumtype that represents whether the file exists or not.
- change the input. Nobody knows what ~Maybe Text -> Text~ means.
** TODO make lenses for Module data type, from CST module
- make lenses for Module data type, to be used in ~updateRouteModule~ function.
- this should replace the getter functions in ~UmuHalogen.Capability.Generation.Route~
** TODO mkRouteItem
- It's currently a hard coded record, can probably be refactered with optics.
* Progress
** <2020-04-24 Fri>
- addressed issues:
  - generate input directory
  - renamed html to assets
  - generate file for hot module reloading.
** <2020-05-03 Sun>
- rename UmuHalogen.Capability.Managecommand to UmuHalogen.Capability.Command
- expiremented on how to generate the write filename and component name.
- created component template
** <2020-05-04 Mon>
- [X] added ~component~ component to generate a component to a specified location.
- [X] move UmuHalogen.Commmand to UmuHalogen.Parser.Command
- parse path input and component name input
- [X] bug: with input ~example/src Component.Name~ will generate filename Component.Name.purs
  - module name needs to be ~module <Directory Name>.<Component name> where~
  - idea: parse the path. Filter out the lowercase part of the path, take the
    Uppercase segments and append it with the ~componentName~.
    - example: ~example/src/Component Name~ will result in
      ~module Component.Name where~
- [X] bug: current logic overwrites file.
- removed microlens-th depedency
- derived lenses manually.
- refactored the line that was checking if the file exists to ~isFileExists~.
  It's is stored in Umuhalogen.Util
- renamed ~mLoc~ input to ~mPathInput~
- [X] refactor the filePath input and put it in the ~where~ clause.
- [X] rename "Generating" to "Generated", and remove ellipsis
- [X] refactor the writeTextFile line in every function
- refactored if..then..else in file generation functions
- refactored directory generation function, it had the dirName as hard-coded
  texts scaterred in the function
** <2020-05-05 Tue>
- update README with console output
** <2020-05-12 Tue>
- [X] pull github mirror
** <2020-05-13 Wed>
- added information like ~Slot~ and ~SProxy~ to generated component
- added ~rawComponentName~ parameter to ~componentTemplate~
- renamed ~UmuHaloge.Capability.LogMessage~ to ~UmuHalogen.Capability.Log~
** <2020-05-14 Thu>
- refactored ~spago.dhall~ file to use parent directory as project name.
** <2020-05-15 Fri>
- created tag and updated changelog
** <2020-05-17 Sun>
- refactored file generation function and directory generation function. Check
  on file/dir existence and file/dir generation are contained in a function and reused.
- Created WriteDirReq and WriteFileReq, these records contain the information to
  to generate files and directories.
- started the router generation feature.
- [X] generate route file, this should only take ~LOCATION~ of the project so it
  can be appended with ~<LOCATION> <> /src/Service/Route.purs~
  - need the route codec.
- [X] generate router component file.
- [X] generate Navigate service file.
- [X] create Page directory
- [X] import Title component in Page.Home
** <2020-05-18 Mon>
- test how easy/hard it is to setup a router
- [X] drop closing bracket in ~routeCodec~ in Route.purs
- moved navigate and route from templates to file. They didn't need user inputs.
- *What if I just include the routing in the initial generation?*
  - This will prevent me from manipulating the ~Main.purs~ file.
- added routing to initial generation.
  - It now comes with Home and About page and a router that switches between
    these two pages.
- refactor: clean up typos and comments
** <2020-05-19 Tue>
- started working on exporing error in the application monad.
- app now exposes depedency and error
** <2020-05-20 Wed>
- expirement on how to parse a path then transform it into module name.
- able to parse a url with parsec "src/example" will result to
  [ "src", "example" ]
- able to parse path input and tokenize it using the ModuleName constructor from Language.Purescript
- successfully parsed input and created module name and component name.
** <2020-05-22 Fri>
- expirement with purescript in a new project
- consuming purescript file, parsing, and lexing using ~CST.parseFromFile~
- [ ] print the output of ~CST.parseFromFile~
  - there is no function that can directly print module.
- [ ] create custom function to print what's inside ~Module~.
** <2020-05-23 Sat>
- mapped the cst output
** <2020-05-24 Sun>
- attempting to filter the data type I need
- attempted to add to sepTail, no success yet.
** <2020-05-25 Mon>
- just dug into Separated data type.
** <2020-05-27 Wed>
- [X] parse command
- purescript dependency doesn't export ~printModule~. So I need to clone the
  repo and add it to my project until they release a separate package.
- integrated purescript library
** <2020-05-28 Thu>
- [X] implement generation of route
- [X] change isNewLine ( Bool ) parameter in mkDataCtor to a sumtype that
  represents NewLine | SameLine
- [X] this will only return the tail part of the constructors.
  #+begin_src
    data Route = Home | About
                 ^head   ^ tail
    if there's only one tail, it will only return one line number.
    Solution. I need to append the in number of head to the result here.
  #+end_src
** <2020-06-01 Mon>
- continued expirementing on consuming a module and updating the routeCodec
- I can update the routeCodec, but the update needs to be exclusive to the routeCodec.
- successfully updated ~routeCodec~. The experiment is in hs-playground/consume-purescript-function
- implemented ~routeCodec~ update.
** <2020-06-02 Tue>
- Learning how to build haskell projects with nix, especially projects with
  multiple packages.
** <2020-06-03 Wed>
- moved umu-halogen project into it's own folder, separate from purescript.
  - [X] ghcid works
  - [X] nix-shell works
  - [X] make build works
- cannot go into nix-shell, complaining about protolude 0.2.3 for missing
  private dependecy base >4.6 && <4.13
- try separating purescript-cst and purescript-ast without purescript
- separated purescript-cst and purescript-ast, i got the same error regarding
  the protolude version. changed ghc version to 8.10.1 from 8.8.3 and it's compiling
  - this fails with the memory package.
- trying out stack2nix
- [X] try building purescript-ast by itself. since this package doesn't depend
  on purescript-ast
** <2020-06-04 Thu>
- successfully built with nix.
- successfully switch to nix-shell.
